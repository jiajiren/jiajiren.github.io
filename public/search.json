[{"title":"信息安全法律法规","url":"/2020/03/18/信息安全法律法规/","content":"\n\n\n\n\n\n\n信息安全法律法规\n\n","tags":["安全"]},{"title":"安全概述","url":"/2020/03/18/安全概述/","content":"\n信息安全工程师考试大纲 \n2月报名 5月考试\n一、考试说明\n1.考试目标\n通过本考试的合格人员能掌握信息安全的知识体系；能够根据应用单位的信息安全需求和信息基础设施结构，规划设计信息安全方案，并负责单位信息系统安全设施的运行维护和配置管理；能够对信息系统运行安全风险和信息设备的安全风险进行监测和分析，并处理一般的安全风险问题，对于重大安全风险问题能够提出整改建议；能够协助相关部门对单位的信息系统进行安全审计和安全事件调查；能够对信息系统和网络安全事件进行关联分析、应急处理，并撰写处理报告；具有工程师的实际工作能力和业务水平。\n2.考试要求\n（1）熟悉信息安全的基本知识；\n（2）熟悉计算机网络、操作系统、数据库管理系统的基本知识；\n（3）熟悉密码学的基本知识与应用技术；\n（4）掌握计算机安全防护与检测技术；\n（5）掌握网络安全防护与处理技术；\n（6）熟悉数字水印在版权保护中的应用技术；\n（7）了解信息安全相关的法律法规、管理规定；\n（8）了解信息安全标准化知识；\n（9）了解安全可靠的软硬件平台的基础知识、集成技术和基础应用；\n（10）了解云计算、物联网、互联网、工业控制、大数据等领域的安全管理、安全技术集成及应用解决方案；\n（11）熟练阅读和正确理解相关领域的英文资料。\n3.考试科目设置\n（1）信息安全基础知识，考试时间为150分钟，笔试，选择题；\n（2）信息安全应用技术，考试时间为150分钟，笔试，问答题。\n二、考试范围\n考试科目1：信息安全基础知识\n1.信息安全基本知识\n1.1信息安全概念\n1.2信息安全法律法规\n1.2.1我国立法与司法现状\n1.2.2计算机和网络安全的法规规章\n1.3信息安全管理基础\n1.3.1信息安全管理制度与政策\n1.3.2信息安全风险评估与管理\n1.4信息安全标准化知识\n1.4.1熟悉信息安全技术标准的基本知识\n1.4.2了解标准化组织\n1.4.3信息安全系列标准\n1.5信息安全专业英语\n2.计算机网络基础知识\n2.1计算机网络的体系结构\n2.2 Internet协议\n2.2.1网络层协议\n2.2.2传输层协议\n2.2.3应用层协议\n3.密码学\n3.1密码学的基本概念\n3.1.1密码学定义\n3.1.2密码体制\n3.1.3古典密码\n3.2分组密码\n3.2.1分组密码的概念\n3.2.2 DES\n3.2.3 AES\n3.2.4 SM4\n3.2.5分组密码工作模式\n3.3序列密码\n3.3.1序列密码的概念\n3.3.2线性移位寄存器序列\n3.3.3 RC4\n3.3.4 ZUC\n3.4 Hash函数\n3.4.1 Hash函数的概念\n3.4.2 SHA算法\n3.4.3 SM3算法\n3.4.4 HMAC\n3.5公钥密码体制\n3.5.1公钥密码的概念\n3.5.2 RSA密码\n3.5.3 ElGamal密码\n3.5.4椭圆曲线密码\n3.5.5 SM2椭圆曲线公钥加密算法\n3.6数字签名\n3.6.1数字签名的概念\n3.6.2典型数字签名体制\n3.6.3 SM2椭圆曲线数字签名算法\n3.7认证\n3.7.1认证的概念\n3.7.2身份认证\n3.7.3报文认证\n3.8密钥管理\n3.8.1密钥管理的概念\n3.8.2对称密码的密钥管理\n3.8.3非对称密码的密钥管理\n4.网络安全\n4.1网络安全的基本概念\n4.2网络安全威胁\n4.2.1威胁来源和种类\n4.2.2网站安全威胁\n4.2.3无线网络安全威胁\n4.3网络安全防御\n4.3.1网络安全防御原则\n4.3.2基本防御技术\n4.3.3安全协议\n4.4无线网络安全\n4.4.1无线网络基本知识\n4.4.2无线网络安全威胁及分析\n4.4.3无线网络安全机制\n5.计算机安全\n5.1计算机设备安全\n5.1.1计算机安全的定义\n5.1.2计算机系统安全模型与安全方法\n5.1.3电磁泄露和干扰\n5.1.4物理安全\n5.1.5计算机的可靠性技术\n5.2操作系统安全\n5.2.1操作系统安全基本知识\n5.2.2操作系统面临的安全威胁\n5.2.3安全模型\n5.2.4操作系统的安全机制\n5.2.5操作系统安全增强的实现方法\n5.3数据库系统的安全\n5.3.1数据库安全的概念\n5.3.2数据库安全的发展历程\n5.3.3数据库访问控制技术\n5.3.4数据库加密\n5.3.5多级安全数据库\n5.3.6数据库的推理控制问题\n5.3.7数据库的备份与恢复\n5.4恶意代码\n5.4.1恶意代码定义与分类\n5.4.2恶意代码的命名规则\n5.4.3计算机病毒\n5.4.4网络蠕虫\n5.4.5特洛伊木马\n5.4.6后门\n5.4.7其他恶意代码\n5.4.8恶意代码的清除方法\n5.4.9典型反病毒技术\n5.5计算机取证\n5.5.1计算机取证的基本概念\n5.5.2电子证据及特点\n5.5.3计算机取证技术\n5.6嵌入式系统安全\n5.6.1智能卡安全基础知识\n5.6.2 USB Key技术\n5.6.3移动智能终端\n5.6.4熟悉工控系统安全问题及解决途径\n5.7云计算安全\n5.7.1云计算安全基础知识\n5.7.2 IaaS层安全技术\n5.7.3 PaaS层安全技术\n5.7.4 SaaS层安全技术\n6.应用系统安全\n6.1 Web安全\n6.1.1 Web安全威胁\n6.1.2 Web安全威胁防护技术\n6.2电子商务安全\n6.2.1电子商务安全基础知识\n6.2.2电子商务的安全认证体系\n6.2.3电子商务的安全服务协议\n6.3信息隐藏\n6.3.1信息隐藏基础知识\n6.3.2数字水印技术\n6.4网络舆情\n6.4.1网络舆情的基本概念&#61623;\n6.4.2网络舆情的基本技术\n6.5隐私保护\n6.5.1隐私保护基础知识\n6.5.2数据挖掘和隐私保护\n6.5.3隐私度量与评估标准\n考试科目2：信息安全应用技术\n1.密码学应用\n1.1密码算法的实现\n1.2密码算法的应用\n1.2.1典型密码算法的应用\n1.2.2分组密码工作模式\n1.2.3公钥密码应用\n1.3典型认证协议的应用\n1.3.1身份认证\n1.3.2典型认证协议的应用\n1.4密钥管理技术\n2.网络安全工程\n2.1网络安全需求分析与基本设计\n2.2网络安全产品的配置与使用\n2.2.1网络流量监控和协议分析\n2.2.2网闸的配置与使用\n2.2.3防火墙的配置与使用\n2.2.4入侵检测系统的配置与使用\n2.3网络安全风险评估实施\n2.3.1基本原则与流程\n2.3.2识别阶段工作\n2.3.3风险分析阶段工作\n2.3.4风险处置\n2.4网络安全防护技术的应用\n2.4.1网络安全漏洞扫描技术及应用\n2.4.2 VPN技术及应用\n2.4.3网络容灾备份技术及应用\n2.4.4日志分析\n3.系统安全工程\n3.1访问控制\n3.1.1访问控制技术\n3.1.2身份认证技术&#61623;\n3.2信息系统安全的需求分析与设计\n3.2.1信息系统安全需求分析\n3.2.2信息系统安全的设计\n3.3信息系统安全产品的配置与使用\n3.3.1 Windows系统安全配置\n3.3.2 Linux系统安全配置\n3.3.3数据库的安全配置\n3.4信息系统安全测评\n3.4.1信息系统安全测评的基础与原则\n3.4.2信息系统安全测评方法\n3.4.3信息系统安全测评过程\n4.应用安全工程\n4.1 Web安全的需求分析与基本设计\n4.1.1 Web安全威胁\n4.1.2 Web安全威胁防护技术\n4.2电子商务安全的需求分析与基本设计\n4.3嵌入式系统的安全应用\n4.3.1嵌入式系统的软件开发\n4.3.2移动智能终端\n4.4数字水印在版权保护中的应用\n4.5位置隐私保护技术的应用\n4.5.1位置隐私安全威胁\n4.5.2位置隐私k-匿名模型的算法和应用\n信息安全工程师有两个考试科目，包含信息安全基础知识与信息安全应用技术两个科目。因此要参加2018上半年信息安全工程师考试的考生要按照考试大纲的章节内容来复习，掌握好这些知识点，这样才能帮助通过考试。","tags":["安全"]},{"title":"Python中新式类和经典类(旧式类)的区别","url":"/2019/12/24/Python中新式类和经典类-旧式类-的区别/","content":"Python2.x中，默认都是经典类，只有显式继承了object的才是新式类，即：\n\n    class Person(object):pass    新式类\n    class Person():pass    经典类\n\n在Python 3.x中取消了经典类，默认都是新式类，并且不必显式的继承object，也就是说：\n\n    class Person(object):pass    新式类\n    class Person():pass     新式类\n\n`新式类`和`经典类（旧式类）`的`区别`的在于`子类多继承`的情况下，`经典类`多继承搜索顺序是`深度优先`，`新式类`多继承搜索顺序是`广度优先`。\n\n具体代码示例如下：\n\n**1. 经典类-- 深度优先**\n\n```\nclass Person():\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Person.\")\n\n\nclass Man(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Man.\")\n\n\nclass Woman(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Woman.\")\n\n\nclass Child(Man,Woman):\n    def __init__(self):\n        pass\n\n\nchild = Child()\nchild.say_hello()\n```\n输出为：  `Hello, I'm Man.`   即调用的是Man中的say_hello()方法。\n\n注释掉Man中的say_hello()方法我们再次执行：\n```\nclass Person():\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Person.\")\n\n\nclass Man(Person):\n    def __init__(self):\n        pass\n    # def say_hello(self):\n    #     print(\"Hello, I'm Man.\")\n\n\nclass Woman(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Woman.\")\n\n\nclass Child(Man,Woman):\n    def __init__(self):\n        pass\n\n\nchild = Child()\nchild.say_hello()\n```\n这是输出的是：`Hello, I'm Person.`  即执行的是Man的父类Person的say_hello()方法。\n\n也就说Man中无此方式时，优先去查找Man的父类Person中的方法，也就证明了多继承的情况下，经典类是`深度优先`的。\n\n\n**2. 新式类-- 广度优先**\n\n```\n#这里基类Person显式的继承了object\nclass Person(object):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Person.\")\n\n\nclass Man(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Man.\")\n\n\nclass Woman(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Woman.\")\n\n\nclass Child(Man,Woman):\n    def __init__(self):\n        pass\n\nchild = Child()\nchild.say_hello()\n```\n这时的输出为：`Hello, I'm Man.` ，即执行的是Man中的say_hello()方法。\n\n然后我们将Man中的say_hello()方法注释掉，再次执行：\n```\n#这里基类Person显式的继承了object\nclass Person(object):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Person.\")\n\n\nclass Man(Person):\n    def __init__(self):\n        pass\n    # def say_hello(self):\n    #     print(\"Hello, I'm Man.\")\n\n\nclass Woman(Person):\n    def __init__(self):\n        pass\n    def say_hello(self):\n        print(\"Hello, I'm Woman.\")\n\n\nclass Child(Man,Woman):\n    def __init__(self):\n        pass\n\nchild = Child()\nchild.say_hello()\n```\n这是的输出为：`Hello, I'm Woman.` ，即执行的Woman中的say_hello()方法。\n\n也就是当Man中无此方法时，优先的去Woman中查找，即`广度优先`。","tags":["Python"]}]